<html>
  <head>
    <title>Simple WebRTC Demo</title>
  </head>
  <body style="color: white; background: black">
    <h1>Simple WebRTC Demo</h1>
    <p>
      This won't work with a symmetric NAT out of the box, which affects about 1
      in 10 users. You'll want to route traffic through what's called a
      <a href="https://webrtc.org/getting-started/turn-server">TURN server</a>
      , which costs money.
    </p>
    <pre>My ID: <span class="myId">loading...</span></pre>
    <button id="startCall">Start Call</button>
    <button id="receiveCall">Receive Call</button>
    <hr />
    <div style="display: flex; flex-direction: column; gap: 1rem">
      <div>
        <video
          id="localVideo"
          autoplay
          muted
          style="border: 2px solid white"
        ></video>
        <br />
        <label for="videoSource">ðŸ“¹</label>
        <select id="videoSource"></select>
        <br />
        <label for="audioSource">ðŸŽ¤</label>
        <select id="audioSource"></select>
        <br />
        <pre>ðŸ‘†You: <span class="myId">loading...</span></pre>
      </div>
      <div>
        <video
          id="remoteVideo"
          autoplay
          style="border: 2px solid white"
        ></video>
        <pre>ðŸ‘†Them: <span class="theirId">[Get into a call first]</span></pre>
      </div>
    </div>
    <hr />
    <p><em>What's happening behind the scenes</em></p>
    <pre id="console" style="padding-bottom: 10rem"></pre>
    <hr />

    <script>
      const addToConsole = (log) => {
        const consl = document.getElementById("console");
        consl.innerHTML += log + "\n";
      };

      let targetId = null;
      const peer = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });
      let localStream;

      let ws;
      let isConnected = false;
      let reconnectInterval;
      const connectWebSocket = () => {
        ws = new WebSocket("ws://localhost:3000/ws");

        ws.onopen = () => {
          addToConsole(
            `âœ… Communication with server established (through a websocket at /ws)`,
          );
          isConnected = true;
          console.log("clearing reconnect interval");
          clearInterval(reconnectInterval);
          reconnectInterval = null;
        };

        ws.onmessage = async (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === "welcome") {
            const myId = msg.id;
            document.querySelectorAll(".myId").forEach((el) => {
              el.innerHTML = `${myId}`;
            });
            addToConsole(`â„¹ï¸ The server gave you an ID of ${myId}`);
            return;
          }
          if (msg.type === "offer") {
            targetId = msg.from;
            await peer.setRemoteDescription(
              new RTCSessionDescription(msg.payload),
            );
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            addToConsole(
              `â„¹ï¸ Received offer from ${targetId}\n   Now sending answer back`,
            );
            ws.send(
              JSON.stringify({
                type: "answer",
                target: targetId,
                payload: answer,
              }),
            );
          }
          if (msg.type === "answer") {
            await peer.setRemoteDescription(
              new RTCSessionDescription(msg.payload),
            );
            addToConsole(`â„¹ï¸ Received answer`);
          }
          if (msg.type === "candidate") {
            peer.addIceCandidate(new RTCIceCandidate(msg.payload));
            addToConsole(`â„¹ï¸ Received ICE candidate`);
          }
        };

        ws.onclose = () => {
          console.log("websocket closed");
          addToConsole(
            `âŒ Communication with server has been stopped (websocket closed)`,
          );
          isConnected = false;
          attemptReconnect();
        };

        ws.onerror = (error) => {
          console.error("websocket error", error);
          addToConsole(
            `âŒ Communication with server has been stopped (websocket error)`,
          );
          isConnected = false;
        };
      };

      async function populateDeviceList() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoSelect = document.getElementById("videoSource");
        const audioSelect = document.getElementById("audioSource");

        videoSelect.innerHTML = "";
        audioSelect.innerHTML = "";

        devices.forEach((device) => {
          const option = document.createElement("option");
          option.value = device.deviceId;
          option.text =
            device.label || `${device.kind} ${videoSelect.length + 1}`;

          if (device.kind === "videoinput") {
            videoSelect.appendChild(option);
          } else if (device.kind === "audioinput") {
            audioSelect.appendChild(option);
          }
        });
      }

      populateDeviceList();

      async function startCall(isInitiator) {
        addToConsole(
          `â„¹ï¸ Adding selected audio and video to my peer connection`,
        );

        const videoSource = document.getElementById("videoSource").value;
        const audioSource = document.getElementById("audioSource").value;
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: videoSource ? { exact: videoSource } : undefined },
          audio: { deviceId: audioSource ? { exact: audioSource } : undefined },
        });

        localStream
          .getTracks()
          .forEach((track) => peer.addTrack(track, localStream));

        peer.onicecandidate = (event) => {
          addToConsole(`â„¹ï¸ peer.onicecandidate`);
          if (event.candidate && targetId) {
            document.querySelectorAll(".theirId").forEach((el) => {
              el.innerHTML = `${targetId}`;
            });
            console.log(targetId);
            ws.send(
              JSON.stringify({
                type: "candidate",
                target: targetId,
                payload: event.candidate,
              }),
            );
          }
        };

        peer.ontrack = (event) => {
          addToConsole(`â„¹ï¸ peer.ontrack`);
          const remoteVideo = document.getElementById("remoteVideo");
          remoteVideo.srcObject = event.streams[0];
        };

        if (isInitiator) {
          targetId = prompt("Enter ID of the peer to call:");
          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          addToConsole(
            `â„¹ï¸ Sending offer to ${targetId} through the server (via websocket)`,
          );
          ws.send(
            JSON.stringify({ type: "offer", target: targetId, payload: offer }),
          );
        }

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
      }

      const attemptReconnect = () => {
        if (reconnectInterval) {
          console.log("already have a reconnect interval", reconnectInterval);
          return;
        } else {
          console.log("starting reconnect interval");
          reconnectInterval = setInterval(() => {
            console.log("attempting reconnect");
            addToConsole(
              `â„¹ï¸ Attempting to reconnect to server again (websocket at /ws, every 3s)`,
            );
            connectWebSocket();
          }, 3000);
        }
      };

      connectWebSocket();

      // Call startCall(true) to initiate
      // Call startCall(false) to receive
      document.getElementById("startCall").addEventListener("click", () => {
        startCall(true);
      });
      document.getElementById("receiveCall").addEventListener("click", () => {
        startCall(false);
      });
    </script>
  </body>
</html>
