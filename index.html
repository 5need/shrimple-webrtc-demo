<html>
  <head>
    <title>Simple WebRTC Demo</title>
  </head>
  <body style="color: white; background: black">
    <h1>Simple WebRTC Demo</h1>
    <p>
      This won't work with a symmetric NAT out of the box, which affects about 1
      in 10 users. You'll want to route traffic through what's called a
      <a href="https://webrtc.org/getting-started/turn-server">TURN server</a>
      , which costs money.
    </p>
    <pre>My ID: <span class="myId">loading...</span></pre>
    <button id="startCall">Call using their ID</button>
    <hr />
    <div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 2rem">
      <div>
        <video
          id="localVideo"
          autoplay
          muted
          style="border: 2px solid white; max-width: 300px"
        ></video>
        <pre>ğŸ‘†You: <span class="myId">loading...</span></pre>
        <button
          id="enableVideoAudio"
          style="font-weight: bold; font-size: 1.25rem"
        >
          ğŸ‘‰ Enable Video/Audio ğŸ‘ˆ
        </button>
        <div id="select">
          <label for="videoSource">ğŸ“¹</label>
          <select id="videoSource"></select>
          <br />
          <label for="audioSource">ğŸ¤</label>
          <select id="audioSource"></select>
        </div>
      </div>
      <div>
        <video
          id="remoteVideo"
          autoplay
          style="border: 2px solid white; max-width: 300px"
        ></video>
        <pre>ğŸ‘†Them: <span class="theirId">[Get into a call first...]</span></pre>
      </div>
    </div>
    <hr />
    <p><em>What's happening behind the scenes</em></p>
    <pre id="console" style="padding-bottom: 10rem"></pre>
    <hr />

    <script>
      const addToConsole = (log) => {
        const consl = document.getElementById("console");
        consl.innerHTML += log + "\n";
      };

      let targetId = null;
      const peer = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });
      let localStream;

      let ws;
      let isConnected = false;
      let reconnectInterval;
      const connectWebSocket = () => {
        ws = new WebSocket("ws://localhost:3000/ws");

        ws.onopen = () => {
          addToConsole(
            `âœ… Communication with server established (through a websocket at /ws)`,
          );
          isConnected = true;
          console.log("clearing reconnect interval");
          clearInterval(reconnectInterval);
          reconnectInterval = null;
        };

        ws.onmessage = async (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === "welcome") {
            const myId = msg.id;
            document.querySelectorAll(".myId").forEach((el) => {
              el.innerHTML = `${myId}`;
            });
            addToConsole(`â„¹ï¸ The server gave you an ID of <b>${myId}</b>`);
            return;
          }
          if (msg.type === "offer") {
            targetId = msg.from;
            await peer.setRemoteDescription(
              new RTCSessionDescription(msg.payload),
            );
            const answer = await peer.createAnswer();
            await peer.setLocalDescription(answer);
            addToConsole(
              `â„¹ï¸ Received offer from ${targetId}\n   Now sending answer back`,
            );
            ws.send(
              JSON.stringify({
                type: "answer",
                target: targetId,
                payload: answer,
              }),
            );
          }
          if (msg.type === "answer") {
            await peer.setRemoteDescription(
              new RTCSessionDescription(msg.payload),
            );
            addToConsole(`â„¹ï¸ Received answer`);
          }
          if (msg.type === "candidate") {
            peer.addIceCandidate(new RTCIceCandidate(msg.payload));
            addToConsole(`â„¹ï¸ Received ICE candidate`);
          }
        };

        ws.onclose = () => {
          console.log("websocket closed");
          addToConsole(
            `âŒ Communication with server has been stopped (websocket closed)`,
          );
          isConnected = false;
          attemptReconnect();
        };

        ws.onerror = (error) => {
          console.error("websocket error", error);
          addToConsole(
            `âŒ Communication with server has been stopped (websocket error)`,
          );
          isConnected = false;
        };
      };

      async function populateDeviceList() {
        try {
          await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoSelect = document.getElementById("videoSource");
          const audioSelect = document.getElementById("audioSource");

          videoSelect.innerHTML = "";
          audioSelect.innerHTML = "";

          devices.forEach((device) => {
            const option = document.createElement("option");
            option.value = device.deviceId;
            option.text =
              device.label || `${device.kind} ${videoSelect.length + 1}`;

            if (device.kind === "videoinput") {
              videoSelect.appendChild(option);
            } else if (device.kind === "audioinput") {
              audioSelect.appendChild(option);
            }
          });
        } catch (err) {
          addToConsole(
            `â€¼ï¸ Video/Audio permissions were denied, enable them please`,
          );
        }
      }

      async function prepareToCall() {
        addToConsole(
          `â„¹ï¸ Adding selected video and audio to my peer connection`,
        );

        // first remove all the previous video and audio sources
        peer.getSenders().forEach((sender) => {
          peer.removeTrack(sender);
        });

        const videoSource = document.getElementById("videoSource").value;
        const audioSource = document.getElementById("audioSource").value;
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: videoSource ? { exact: videoSource } : undefined },
          audio: { deviceId: audioSource ? { exact: audioSource } : undefined },
        });

        localStream
          .getTracks()
          .forEach((track) => peer.addTrack(track, localStream));

        peer.onicecandidate = (event) => {
          addToConsole(`â„¹ï¸ peer.onicecandidate`);
          if (event.candidate && targetId) {
            document.querySelectorAll(".theirId").forEach((el) => {
              el.innerHTML = `${targetId}`;
            });
            console.log(targetId);
            ws.send(
              JSON.stringify({
                type: "candidate",
                target: targetId,
                payload: event.candidate,
              }),
            );
          }
        };

        peer.ontrack = (event) => {
          addToConsole(`â„¹ï¸ peer.ontrack`);
          const remoteVideo = document.getElementById("remoteVideo");
          remoteVideo.srcObject = event.streams[0];
        };

        const localVideo = document.getElementById("localVideo");
        localVideo.srcObject = localStream;
      }

      async function startCall() {
        targetId = prompt("Enter ID of the other client to call:");
        if (!!targetId) {
          const offer = await peer.createOffer();
          await peer.setLocalDescription(offer);
          addToConsole(
            `â„¹ï¸ Sending offer to ${targetId} through the server (via websocket)`,
          );
          ws.send(
            JSON.stringify({ type: "offer", target: targetId, payload: offer }),
          );
        }
      }

      const attemptReconnect = () => {
        if (reconnectInterval) {
          console.log("already have a reconnect interval", reconnectInterval);
          return;
        } else {
          console.log("starting reconnect interval");
          reconnectInterval = setInterval(() => {
            console.log("attempting reconnect");
            addToConsole(
              `â„¹ï¸ Attempting to reconnect to server again (websocket at /ws, every 3s)`,
            );
            connectWebSocket();
          }, 3000);
        }
      };

      connectWebSocket();

      document.getElementById("startCall").addEventListener("click", () => {
        startCall();
      });
      document.getElementById("videoSource").addEventListener("input", () => {
        prepareToCall();
      });
      document.getElementById("audioSource").addEventListener("input", () => {
        prepareToCall();
      });
      document.getElementById("audioSource").addEventListener("input", () => {
        prepareToCall();
      });
      document
        .getElementById("enableVideoAudio")
        .addEventListener("click", (e) => {
          populateDeviceList();
          prepareToCall();
          e.target.remove();
        });
    </script>
  </body>
</html>
